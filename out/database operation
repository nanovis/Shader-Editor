db.shader.insert(
[
{name:"fire",user:"admin",status:"Public",path:"/view/fire",canvas_only_path:"/canvas/fire",code:"//refer to https://glslsandbox.com/e#80331.0\n@fragment\nfn main(@builtin(position) position: vec4<f32>) -> @location(0) vec4<f32> {\nvar glsl_position:vec2<f32>=vec2<f32>(position.x,Resolution.y-position.y);\nvar uv:vec2<f32>=vec2<f32>((glsl_position-(0.7*Resolution.xy))/Resolution.y);\nvar x:f32=uv.x*3.0;\nvar y:f32=uv.y*4.0;\nvar m:f32= 1.0-(y*9.0)*(12.0+sin(-Time/4.0)*0.6)*0.7+sin(y*3.0+x*2.0-Time*9.0)*sin(y*1.7-x*6.0-Time+sin(x*3.0-y*0.3-Time*2.0)+cos(Time/6.0-y*6.0+x*6.0)/3.0)*69.0;\nreturn vec4<f32>(m*0.016,m*0.008,m*0.001,1.0);\n}",texture1:"admin_black.jpg",texture2:"admin_black.jpg",texture3:"admin_black.jpg",texture4:"admin_black.jpg",jsname:"fire.js"},
{name:"mc",user:"admin",status:"Public",path:"/view/mc",canvas_only_path:"/canvas/mc",code:"//refer to https://glslsandbox.com/e#80430.0 \n@fragment\nfn main(@builtin(position) position: vec4<f32>) -> @location(0) vec4<f32> {\n  var glsl_position:vec2<f32>=vec2<f32>(position.x,Resolution.y-position.y);\n  var normalized_dot:vec3<f32>=normalize(vec3<f32>((glsl_position.xy-Resolution.xy*0.55)/Resolution.x,0.1));\n  var sized:vec3<f32>=vec3<f32>(7.0);\n  var foreground:vec3<f32>=vec3<f32>(14.0);\n  var fracted_normalized_dot:vec3<f32>=vec3<f32>(8.0);\n  var camera:vec3<f32>=vec3<f32>(0.0);\n  var background:vec3<f32>=normalized_dot;\n  var light:vec3<f32>=vec3<f32>(1.0,2.5,0.0);\n  camera.x=0.99;\n  camera.z=Time*9.0;\n  camera.y=1.3*cos(camera.x*camera.z);\n  camera.x=camera.x-sin(Time)+3.0;\n  for(var depth: f32 = 0.00; depth< 21.0; depth=depth+0.05) {\n  camera=camera+normalized_dot*depth*0.09;\n  foreground = camera;\n  fracted_normalized_dot=fract(foreground);\n  sized = floor( foreground )*0.4;\n  sized.y=sized.y+3.0;\n  if ((cos(sized.z) + sin(sized.x)) > sized.y){\n  var flag:f32=fracted_normalized_dot.y-(0.04*cos((foreground.x+foreground.z)*40.0));\n  if (flag>0.5)\n  {\n    background = light/depth;\n  }\n  else\n  {\n   background =(fracted_normalized_dot.x*light.yxz)/depth;\n  }\n    break;\n  }\n}\n  return vec4<f32>(background,9.9);\n}\n",texture1:"admin_black.jpg",texture2:"admin_black.jpg",texture3:"admin_black.jpg",texture4:"admin_black.jpg",jsname:"mc.js"},
{name:"simpletexture",user:"admin",status:"Public",path:"/view/simpletexture",canvas_only_path:"/canvas/simpletexture",code:"@fragment\nfn main(@builtin(position) position: vec4<f32>) -> @location(0) vec4<f32> {\n  var uv:vec2<f32>=vec2<f32>(position.xy/Resolution);\n  if (distance(uv,vec2<f32>(0.5,0.5))<0.5)\n  {\n      return textureSample(texture1, sampler_, position.xy/Resolution);\n  }\n  else\n  {\n      return vec4<f32>(0.0,0.0,0.0,1.0);\n  }\n}",texture1:"admin_London.jpg",texture2:"admin_black.jpg",texture3:"admin_black.jpg",texture4:"admin_black.jpg",jsname:"simpletexture.js"},
{name:"dynamic",user:"admin",status:"Public",path:"/view/dynamic",canvas_only_path:"/canvas/dynamic",code:"//refer to https://www.shadertoy.com/view/7lfyR8 \n @fragment\nfn main(@builtin(position) position: vec4<f32>) -> @location(0) vec4<f32> {\n  var uv:vec2<f32>=vec2<f32>(position.xy/Resolution);\n  var n:f32=100.0;\n  var d:f32=n*abs(sin(Time*0.1));\n  d=d+(Resolution.x-d)*step(n-(30.0),d);\n  return textureSample(texture1, sampler_, floor(uv*d)/d);\n}",texture1:"admin_London.jpg",texture2:"admin_black.jpg",texture3:"admin_black.jpg",texture4:"admin_black.jpg",jsname:"dynamic.js"},
{name:"sample",user:"admin",status:"Public",path:"/view/sample",canvas_only_path:"/canvas/sample",code:"//refer to https://glslsandbox.com/e#80404.1\n@fragment\nfn main(@builtin(position) position: vec4<f32>) -> @location(0) vec4<f32> {\n  var glsl_position:vec2<f32>=vec2<f32>(position.x,Resolution.y-position.y);\n  var uv:vec2<f32>=vec2<f32>(glsl_position/Resolution + (Mouse.xy/Resolution/4.0));\n  var color:f32=0.0;\n  color=color+sin(uv.x*cos(Time/15.0)*80.0)+cos(uv.y*cos(Time/15.0)*10.0);\n  color=color+sin(uv.y*sin(Time/10.0)*40.0)+cos(uv.x*sin(Time/25.0)*40.0);\n color=color+sin(uv.x*sin(Time/5.0)*10.0)+cos(uv.y*sin(Time/35.0)*80.0);\n  color=color*sin(Time/10.0)*0.5;\n  return vec4<f32>(color,color*0.5,sin(color+Time/3.0)*0.75,1.0);\n}",texture1:"admin_black.jpg",texture2:"admin_black.jpg",texture3:"admin_black.jpg",texture4:"admin_black.jpg",jsname:"sample.js"},
{name:"raytracing",user:"admin",status:"Public",path:"/view/raytracing",canvas_only_path:"/canvas/raytracing",code:"//by Mohammed Alnasser\n@fragment\nfn main(@builtin(position) position: vec4<f32>) -> @location(0) vec4<f32> {\n  let width = 800.0;\n  let height = 600.0;\n  let xFact = 1.0 / (width / 2.0);\n  let yFact = 1.0 / (height / 2.0);\n  let aspect = width/height;\n  let PI = 3.141592653589793238; \n  var light: vec3<f32> = vec3<f32>(0.0, 0.0, 5.0);\n  var camera: vec3<f32> = vec3<f32>(0.0, 0.0, 1.0);\n  var cameraUp: vec3<f32> = vec3<f32>(0.0, 1.0, 0.0);\n  var viewDirection: vec3<f32> = vec3<f32>(0.0, 0.0, -1.0);\n\n  var plane1: Object;\n  plane1.color = vec3<f32>(0.5, 0.5, 0.5);\n  var plane1_trans: Transformation;\n  plane1_trans.translation = vec3<f32>(0.0, 1.0, -2.0);\n  plane1_trans.rotation = vec3<f32>(-0.55*PI, -0.0*PI, 0.0*PI);\n  plane1_trans.scale = vec3<f32>(5.0, 5.0, 1.0);\n  plane1.transformations = plane1_trans;\n\n  var sphere1: Object;\n  sphere1.color = vec3<f32>(1.0, 0.0, 0.0);\n  var sphere1_trans: Transformation;\n  sphere1_trans.translation = vec3<f32>(0.0, 0.0, -5.0);\n  sphere1_trans.rotation = vec3<f32>(0.0, 0.0, 0.0);\n  sphere1_trans.scale = vec3<f32>(0.75, 0.75, 0.75);\n  sphere1.transformations = sphere1_trans;\n\n  var sphere2: Object;\n  sphere2.color = vec3<f32>(0.0, 1.0, 0.0);\n  var sphere2_trans: Transformation;\n  sphere2_trans.translation = vec3<f32>(-1.0, 0.0, -3.0);\n  sphere2_trans.rotation = vec3<f32>(0.0, 0.0, 0.0);\n  sphere2_trans.scale = vec3<f32>(0.5, 0.5, 0.5);\n  sphere2.transformations = sphere2_trans;\n\n  var cone1: Object;\n  cone1.color = vec3<f32>(0.0, 0.0, 1.0);\n  var cone1_trans: Transformation;\n  cone1_trans.translation = vec3<f32>(0.0, 0.0, -3.0);\n  cone1_trans.rotation = vec3<f32>(-PI/2.0, -PI, 0.0);\n  cone1_trans.scale = vec3<f32>(0.5, 0.5, 0.5);\n  cone1.transformations = cone1_trans;\n\n  let normX = (position.x * xFact) - 1.0;\n  let normY = (position.y * yFact) - 1.0;\n\n  let alignment = normalize(viewDirection - camera);\n\n  let u = normalize(cross(alignment, cameraUp));\n  let v = normalize(cross(u, alignment)) / aspect;\n\n  let screenCenter = camera + alignment;\n  let screenWorldCoordinate = screenCenter + (u * normX) + (v * normY);\n\n  var cameraRay: Ray;\n  cameraRay.point1 = camera;\n  cameraRay.point2 = screenWorldCoordinate;\n  cameraRay.ab = cameraRay.point2 - cameraRay.point1;\n  \n  let objectCount: i32 = 4;\n  var colors: array<ColorPoint, 4>;\n\n  colors[0] = get_sphere(cameraRay, sphere1, light);\n  colors[1] = get_sphere(cameraRay, sphere2, light);\n  colors[2] = get_cone(cameraRay, cone1, light);\n  colors[3] = get_plane(cameraRay, plane1, light);\n  \n  var min_idx: i32 = 0;\n  var min_dist: f32 = colors[0].distance;\n  for (var i: i32 = 1; i < objectCount; i++) {\n    if (colors[i].distance < min_dist) {\n      min_dist = colors[i].distance;\n      min_idx = i;\n    }\n  }\n  return colors[min_idx].color;\n}\n\nfn get_sphere(cameraRay: Ray,\n              object: Object, \n              light: vec3<f32>) -> ColorPoint {\n  let KA = 0.3;\n  let KD = 0.7;\n  let PI = 3.141592653589793238; \n\n  let back_ray = transform_ray(cameraRay, object.transformations, false);\n  let vhat = normalize(back_ray.ab);\n  var output: ColorPoint;\n  output.color = vec4<f32>(0.0,0.0,0.0,1.0);\n  output.distance = pow(10.0,10.0);\n\n  let b = 2.0 * dot(back_ray.point1, vhat); \n  let c = dot(back_ray.point1, back_ray.point1) - 1.0;\n  let disc = b * b - 4.0 * c;\n  if (disc > 0.0) {\n    let numSQRT = sqrt(disc);\n    let t1 = (-b + numSQRT) / 2.0;\n    let t2 = (-b - numSQRT) / 2.0;\n    \n    if ((t1 < 0.0) || (t2 < 0.0)) {\n      return output;\n    } else {\n      var poi: vec3<f32> = vec3<f32>(0.0,0.0,0.0);\n      if (t1 < t2) {\n        poi = back_ray.point1 + (vhat * t1);\n      } else {\n        poi = back_ray.point1 + (vhat * t2);\n      }\n      let int_point = transform_vec(poi, object.transformations, true);\n      let object_origin: vec3<f32> = vec3<f32>(0.0, 0.0, 0.0);\n      let new_object_origin = transform_vec(object_origin, object.transformations, true);\n      let localNormal = normalize(int_point - new_object_origin);\n\n      let lightDirection:vec3<f32> = normalize(light - poi);\n      \n      let angle: f32 = acos(dot(localNormal, lightDirection));\n      var intensity: f32;\n      if (angle > PI/2.0) {\n        intensity = 0.0;\n      } else {\n        intensity = (1.0 - (angle / (PI / 2.0)));\n      }\n      \n      output.color = vec4<f32>(calculate_pixel(object.color, intensity), 1.0);\n      output.distance = distance(int_point, cameraRay.point2);\n      return output;\n    }\n  } else {\n    return output;\n  }\n}\n\nfn get_cone(cameraRay: Ray,\n            object: Object,\n            light: vec3<f32>) -> ColorPoint {\n  let EPSILON: f32 = pow(10.0, -21.0);\n  let PI = 3.141592653589793238;\n\n  let back_ray = transform_ray(cameraRay, object.transformations, false);\n\n  let p = back_ray.point1;\n  let v = normalize(back_ray.ab);\n\n  var output: ColorPoint;\n  output.color = vec4<f32>(0.0,0.0,0.0,1.0);\n  output.distance = pow(10.0,10.0);\n\n  let a = pow(v[0], 2.0) + pow(v[1], 2.0) - pow(v[2], 2.0);\n  let b = 2.0 * (p[0]*v[0] + p[1]*v[1] - p[2]*v[2]);\n  let c = pow(p[0], 2.0) + pow(p[1], 2.0) - pow(p[2], 2.0);\n  \n  let disc = b * b - 4.0 * a * c;\n  var t: array<f32, 3>;\n  var t_validity: array<bool, 3>;\n  var poi: array<vec3<f32>, 3>;\n  if (disc > 0.0) {\n    let numSQRT = sqrt(disc);\n    if (numSQRT > 0.0) {\n      t[0] = (-b + numSQRT) / (2.0 * a);\n      t[1] = (-b - numSQRT) / (2.0 * a);\n      \n      poi[0] = back_ray.point1 + v * t[0];\n      poi[1] = back_ray.point1 + v * t[1];\n      if ((t[0] > 0.0) && (poi[0][2] > 0.0) && (poi[0][2] < 1.0)) {\n        t_validity[0] = true;\n      } else {\n        t_validity[0] = false;\n        t[0] = pow(10.0, 10.0);\n      }\n\n      if ((t[1] > 0.0) && (poi[1][2] > 0.0) && (poi[1][2] < 1.0)) {\n        t_validity[1] = true;\n      } else {\n        t_validity[1] = false;\n        t[1] = pow(10.0, 10.0);\n      }\n    } else {\n      t_validity[0] = false;\n      t_validity[1] = false;\n      t[0] = pow(10.0, 10.0);\n      t[1] = pow(10.0, 10.0);\n    }\n  }\n\n  if (abs(v[2]) < EPSILON) {\n    t_validity[2] = false;\n    t[2] = pow(10.0, 10.0);\n  } else {  \n    t[2] = (back_ray.point1[2] - 1.0) / - v[2];\n    poi[2] = back_ray.point1 + t[2] * v;\n    \n    if ((t[2] > 0.0) && (sqrt(pow(poi[2][0], 2.0) + pow(poi[2][1], 2.0)) < 1.0)) {\n      t_validity[2] = true;\n    } else {\n      t_validity[2] = false;\n      t[2] = pow(10.0, 10.0);\n    }           \n  }\n  \n  if ((!t_validity[0]) && (!t_validity[1]) && (!t_validity[2])) {\n    return output;  \n  }\n\n  var min_idx: i32 = 0;\n  var min_t: f32 = t[0];\n  for (var i: i32 = 1; i < 3; i++) {\n    if (t[i] < min_t) {\n      min_t = t[i];\n      min_idx = i;\n    }\n  }\n\n  let valid_poi: vec3<f32> = poi[min_idx];\n  if (min_idx < 2) { \n    let local_org = vec3<f32>(0.0, 0.0, 0.0);\n    let global_org = transform_vec(local_org, object.transformations, true);\n\n    let tX = valid_poi[0];\n    let tY = valid_poi[1];\n    let tZ = -sqrt(pow(tX, 2.0) + pow(tY, 2.0));\n    let org_normal = vec3<f32>(tX, tY, tZ);\n    let normal = normalize(transform_vec(org_normal, object.transformations, true) - global_org);\n    \n    let int_point = transform_vec(valid_poi, object.transformations, true);   \n    let lightDirection:vec3<f32> = normalize(light - int_point);\n    \n    let angle: f32 = acos(dot(normal, lightDirection));\n    var intensity: f32;\n    if (angle > PI/2.0) {\n      intensity = 0.0;\n    } else {\n      intensity = (1.0 - (angle / (PI / 2.0)));\n    }\n\n    output.color = vec4<f32>(calculate_pixel(object.color, intensity), 1.0);\n    output.distance = distance(int_point, cameraRay.point2);\n  } else {\n    if (abs(v[2]) > 0.0) {\n      if (sqrt(pow(valid_poi[0], 2.0) + pow(valid_poi[1], 2.0)) < 1.0) {\n        let int_point = transform_vec(valid_poi, object.transformations, true);  \n        let lightDirection:vec3<f32> = normalize(light - int_point);     \n        \n        let local_org = vec3<f32>(0.0, 0.0, 0.0);    \n        var normal = vec3<f32>(0.0, 0.0, 1.0);\n\n        let global_org = transform_vec(local_org, object.transformations, true);\n        normal = normalize(transform_vec(normal, object.transformations, true) - global_org);\n        \n        let angle: f32 = acos(dot(normal, lightDirection));\n        var intensity: f32;\n        if (angle > PI/2.0) {\n          intensity = 0.0;\n        } else {\n          intensity = (1.0 - (angle / (PI / 2.0)));\n        }\n\n        output.color = vec4<f32>(calculate_pixel(object.color, intensity), 1.0);\n        output.distance = distance(int_point, cameraRay.point2);        \n      }    \n    } \n  }\n  return output;\n}\n\nfn get_plane(cameraRay: Ray,\n            object: Object,\n            light: vec3<f32>) -> ColorPoint {\n  let EPSILON: f32 = pow(10.0, -21.0);\n  let PI = 3.141592653589793238;\n\n  var output: ColorPoint;\n  output.color = vec4<f32>(0.2,0.2,0.2,1.0);\n  output.distance = pow(10.0,10.0);\n\n  let back_ray = transform_ray(cameraRay, object.transformations, false);\n  let k = normalize(back_ray.ab);\n\n  let t = back_ray.point1[2] / (-k[2]);\n  if (t > 0.0) {\n    let u = back_ray.point1[0] + t * k[0];\n    let v = back_ray.point1[1] + t * k[1];\n\n    if (abs(u) < 1.0 && abs(v) < 1.0) {\n      let poi = back_ray.point1 + t*k;\n      let int_point = transform_vec(poi, object.transformations, true);\n\n      let local_org = vec3<f32>(0.0, 0.0, 0.0);\n      let global_org = transform_vec(local_org, object.transformations, true);\n      let normal_vector = vec3<f32>(0.0, 0.0, -1.0);\n      let normal = normalize(transform_vec(normal_vector, object.transformations, true) - global_org);\n           \n      let lightDirection:vec3<f32> = normalize(light - int_point);\n      let angle: f32 = acos(dot(normal, lightDirection));\n      var intensity: f32;\n      if (angle > PI/2.0) {\n        intensity = 0.0;\n      } else {\n        intensity = (1.0 - (angle / (PI / 2.0)));\n      }\n\n      output.color = vec4<f32>(calculate_pixel(object.color, intensity), 1.0);\n      output.distance = distance(int_point, cameraRay.point2);     \n    }\n  }\n\n  return output;\n}\n\nfn calculate_pixel(color: vec3<f32>, intensity: f32) -> vec3<f32> {\n  let KA = 0.3;\n  let KD = 0.7;\n  return intensity*(KA + color * KD);\n}\n\nfn transform(transformation: Transformation,\n             direction: bool) -> mat4x4<f32> {\n  var translation: vec3<f32> = transformation.translation;\n  var rotation: vec3<f32> = transformation.rotation;\n  var scale: vec3<f32> = transformation.scale;\n  let id: mat4x4<f32> = mat4x4<f32>(1.0, 0.0, 0.0, 0.0,\n                                    0.0, 1.0, 0.0, 0.0,\n                                    0.0, 0.0, 1.0, 0.0,\n                                    0.0, 0.0, 0.0, 1.0);\n  var translationMatrix: mat4x4<f32>;\n  var rotationMatrixX: mat4x4<f32>;\n  var rotationMatrixY: mat4x4<f32>;\n  var rotationMatrixZ: mat4x4<f32>;\n  var scaleMatrix: mat4x4<f32>;\n  \n  translationMatrix = id;\n  rotationMatrixX = id;\n  rotationMatrixY = id;\n  rotationMatrixZ = id;\n  scaleMatrix = id;\n  \n  translationMatrix[0][3] = translation[0];\n  translationMatrix[1][3] = translation[1];\n  translationMatrix[2][3] = translation[2];\n  rotationMatrixZ[0][0] = cos(rotation[2]);\n  rotationMatrixZ[0][1] = -sin(rotation[2]);\n  rotationMatrixZ[1][0] = sin(rotation[2]);\n  rotationMatrixZ[1][1] = cos(rotation[2]);\n  rotationMatrixY[0][0] = cos(rotation[1]);\n  rotationMatrixY[0][2] = sin(rotation[1]);\n  rotationMatrixY[2][0] = -sin(rotation[1]);\n  rotationMatrixY[2][2] = cos(rotation[1]);\n  rotationMatrixX[1][1] = cos(rotation[0]);\n  rotationMatrixX[1][2] = -sin(rotation[0]);\n  rotationMatrixX[2][1] = sin(rotation[0]);\n  rotationMatrixX[2][2] = cos(rotation[0]);\n  scaleMatrix[0][0] = scale[0];\n  scaleMatrix[1][1] = scale[1];\n  scaleMatrix[2][2] = scale[2];\n\n  var result: mat4x4<f32> =\n      rotationMatrixX *\n      rotationMatrixY *\n      rotationMatrixZ *\n      scaleMatrix *\n      translationMatrix;\n  if (direction) {\n    return result;\n  } else {\n    return inverse(result);\n  }\n}\nfn transform_ray(input: Ray, \n                 transformation: Transformation,\n                 direction: bool) -> Ray {\n  var output: Ray;\n  output.point1 = transform_vec(input.point1, transformation, direction);\n  output.point2 = transform_vec(input.point2, transformation, direction);\n  output.ab = output.point2 - output.point1;\n\n  return output;\n}\n\nfn transform_vec(input: vec3<f32>, \n                 transformation: Transformation,\n                 direction: bool) -> vec3<f32> {\n  var output: vec3<f32>;\n  var trans_matrix: mat4x4<f32> = transform(transformation, direction);\n\n  var result_mat: vec4<f32> = trans_matrix * vec4<f32>(input, 1.0);\n  output = vec3<f32>(result_mat[0], result_mat[1], result_mat[2]);\n\n  return output;\n}\n\nfn inverse(m: mat4x4<f32>) -> mat4x4<f32> {\n  var inv: mat4x4<f32>;\n  var out: mat4x4<f32>;\n  inv[0][0] = m[1][1]  * m[2][2] * m[3][3] - \n            m[1][1]  * m[2][3] * m[3][2] - \n            m[2][1]  * m[1][2]  * m[3][3] + \n            m[2][1]  * m[1][3]  * m[3][2] +\n            m[3][1] * m[1][2]  * m[2][3] - \n            m[3][1] * m[1][3]  * m[2][2];\n  inv[1][0] = -m[1][0]  * m[2][2] * m[3][3] + \n            m[1][0]  * m[2][3] * m[3][2] + \n            m[2][0]  * m[1][2]  * m[3][3] - \n            m[2][0]  * m[1][3]  * m[3][2] - \n            m[3][0] * m[1][2]  * m[2][3] + \n            m[3][0] * m[1][3]  * m[2][2];\n  inv[2][0] = m[1][0]  * m[2][1] * m[3][3] - \n            m[1][0]  * m[2][3] * m[3][1] - \n            m[2][0]  * m[1][1] * m[3][3] + \n            m[2][0]  * m[1][3] * m[3][1] + \n            m[3][0] * m[1][1] * m[2][3] - \n            m[3][0] * m[1][3] * m[2][1];\n  inv[3][0] = -m[1][0]  * m[2][1] * m[3][2] + \n              m[1][0]  * m[2][2] * m[3][1] +\n              m[2][0]  * m[1][1] * m[3][2] - \n              m[2][0]  * m[1][2] * m[3][1] - \n              m[3][0] * m[1][1] * m[2][2] + \n              m[3][0] * m[1][2] * m[2][1];\n  inv[0][1] = -m[0][1]  * m[2][2] * m[3][3] + \n            m[0][1]  * m[2][3] * m[3][2] + \n            m[2][1]  * m[0][2] * m[3][3] - \n            m[2][1]  * m[0][3] * m[3][2] - \n            m[3][1] * m[0][2] * m[2][3] + \n            m[3][1] * m[0][3] * m[2][2];\n  inv[1][1] = m[0][0]  * m[2][2] * m[3][3] - \n            m[0][0]  * m[2][3] * m[3][2] - \n            m[2][0]  * m[0][2] * m[3][3] + \n            m[2][0]  * m[0][3] * m[3][2] + \n            m[3][0] * m[0][2] * m[2][3] - \n            m[3][0] * m[0][3] * m[2][2];\n  inv[2][1] = -m[0][0]  * m[2][1] * m[3][3] + \n            m[0][0]  * m[2][3] * m[3][1] + \n            m[2][0]  * m[0][1] * m[3][3] - \n            m[2][0]  * m[0][3] * m[3][1] - \n            m[3][0] * m[0][1] * m[2][3] + \n            m[3][0] * m[0][3] * m[2][1];\n  inv[3][1] = m[0][0]  * m[2][1] * m[3][2] - \n            m[0][0]  * m[2][2] * m[3][1] - \n            m[2][0]  * m[0][1] * m[3][2] + \n            m[2][0]  * m[0][2] * m[3][1] + \n            m[3][0] * m[0][1] * m[2][2] - \n            m[3][0] * m[0][2] * m[2][1];\n  inv[0][2] = m[0][1]  * m[1][2] * m[3][3] - \n            m[0][1]  * m[1][3] * m[3][2] - \n            m[1][1]  * m[0][2] * m[3][3] + \n            m[1][1]  * m[0][3] * m[3][2] + \n            m[3][1] * m[0][2] * m[1][3] - \n            m[3][1] * m[0][3] * m[1][2];\n  inv[1][2] = -m[0][0]  * m[1][2] * m[3][3] + \n            m[0][0]  * m[1][3] * m[3][2] + \n            m[1][0]  * m[0][2] * m[3][3] - \n            m[1][0]  * m[0][3] * m[3][2] - \n            m[3][0] * m[0][2] * m[1][3] + \n            m[3][0] * m[0][3] * m[1][2];\n  inv[2][2] = m[0][0]  * m[1][1] * m[3][3] - \n            m[0][0]  * m[1][3] * m[3][1] - \n            m[1][0]  * m[0][1] * m[3][3] + \n            m[1][0]  * m[0][3] * m[3][1] + \n            m[3][0] * m[0][1] * m[1][3] - \n            m[3][0] * m[0][3] * m[1][1];\n  inv[3][2] = -m[0][0]  * m[1][1] * m[3][2] + \n              m[0][0]  * m[1][2] * m[3][1] + \n              m[1][0]  * m[0][1] * m[3][2] - \n              m[1][0]  * m[0][2] * m[3][1] - \n              m[3][0] * m[0][1] * m[1][2] + \n              m[3][0] * m[0][2] * m[1][1];\n  inv[0][3] = -m[0][1] * m[1][2] * m[2][3] + \n            m[0][1] * m[1][3] * m[2][2] + \n            m[1][1] * m[0][2] * m[2][3] - \n            m[1][1] * m[0][3] * m[2][2] - \n            m[2][1] * m[0][2] * m[1][3] + \n            m[2][1] * m[0][3] * m[1][2];\n  inv[1][3] = m[0][0] * m[1][2] * m[2][3] - \n            m[0][0] * m[1][3] * m[2][2] - \n            m[1][0] * m[0][2] * m[2][3] + \n            m[1][0] * m[0][3] * m[2][2] + \n            m[2][0] * m[0][2] * m[1][3] - \n            m[2][0] * m[0][3] * m[1][2];\n  inv[2][3] = -m[0][0] * m[1][1] * m[2][3] + \n              m[0][0] * m[1][3] * m[2][1] + \n              m[1][0] * m[0][1] * m[2][3] - \n              m[1][0] * m[0][3] * m[2][1] - \n              m[2][0] * m[0][1] * m[1][3] + \n              m[2][0] * m[0][3] * m[1][1];\n  inv[3][3] = m[0][0] * m[1][1] * m[2][2] - \n            m[0][0] * m[1][2] * m[2][1] - \n            m[1][0] * m[0][1] * m[2][2] + \n            m[1][0] * m[0][2] * m[2][1] + \n            m[2][0] * m[0][1] * m[1][2] - \n            m[2][0] * m[0][2] * m[1][1];\n  var det: f32 = m[0][0] * inv[0][0] + m[0][1] * inv[1][0] + m[0][2] * inv[2][0] + m[0][3] * inv[3][0];\n  det = 1.0 / det;\n  for (var i:i32 = 0; i < 4; i++) {\n    for (var j:i32; j<4; j++) {\n      out[i][j] = inv[i][j] * det;\n    }\n  }\n  return out;\n}\nstruct Ray {\n  point1: vec3<f32>,\n  point2: vec3<f32>,\n  ab: vec3<f32>\n}\nstruct ColorPoint {\n  color: vec4<f32>,\n  distance: f32,\n}\nstruct Transformation {\n  translation: vec3<f32>,\n  rotation: vec3<f32>, \n  scale: vec3<f32>\n}\nstruct Object {\n  color: vec3<f32>,\n  transformations: Transformation\n}",texture1:"admin_black.jpg",texture2:"admin_black.jpg",texture3:"admin_black.jpg",texture4:"admin_black.jpg",jsname:"raytracing.js"}

])

db.texture.insert(
[
{name:"black.jpg",user:"admin",width:"256",height:"256",type:"jpg"},
{name:"happytree.jpg",user:"admin",width:"256",height:"256",type:"jpg"},
{name:"London.jpg",user:"admin",width:"256",height:"256",type:"jpg"},
{name:"stock.jpg",user:"admin",width:"256",height:"256",type:"jpg"},
{name:"wall.jpg",user:"admin",width:"256",height:"256",type:"jpg"},
]
)